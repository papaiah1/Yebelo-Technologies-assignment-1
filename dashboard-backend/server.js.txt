// server.js
const express = require('express');
const { Kafka } = require('kafkajs');
const cors = require('cors');

const app = express();
app.use(cors());

// Config
const PORT = process.env.PORT || 4000;
const KAFKA_BROKER = process.env.KAFKA_BROKER || 'localhost:9092';
const MAX_POINTS = 1000; // how many recent points to keep per symbol

// In-memory store: { symbol -> [ { ts, price } ] } and rsi store
const priceStore = {};
const rsiStore = {};

// Utility to push and cap
function pushCap(store, symbol, point) {
  if (!store[symbol]) store[symbol] = [];
  store[symbol].push(point);
  if (store[symbol].length > MAX_POINTS) store[symbol].shift();
}

// Kafka consumer (kafkajs)
const kafka = new Kafka({
  clientId: 'dashboard-backend',
  brokers: [KAFKA_BROKER],
});

const consumer = kafka.consumer({ groupId: 'dashboard-dashboard-group' });

async function startConsumer() {
  await consumer.connect();

  // Subscribe to trade-data and rsi-data
  await consumer.subscribe({ topic: 'trade-data', fromBeginning: true });
  await consumer.subscribe({ topic: 'rsi-data', fromBeginning: true });

  await consumer.run({
    eachMessage: async ({ topic, partition, message }) => {
      try {
        const payload = message.value.toString();
        const obj = JSON.parse(payload);

        if (topic === 'trade-data') {
          // expected trade message: { trade_id, symbol, price, quantity, timestamp }
          const symbol = obj.symbol || 'UNKNOWN';
          const ts = obj.timestamp || new Date().toISOString();
          const price = typeof obj.price === 'number' ? obj.price : parseFloat(obj.price);
          if (!Number.isNaN(price)) {
            pushCap(priceStore, symbol, { ts, price });
          }
        } else if (topic === 'rsi-data') {
          // expected rsi message: { symbol, rsi, timestamp }
          const symbol = obj.symbol || 'UNKNOWN';
          const ts = obj.timestamp || new Date().toISOString();
          const rsi = typeof obj.rsi === 'number' ? obj.rsi : parseFloat(obj.rsi);
          if (!Number.isNaN(rsi)) {
            pushCap(rsiStore, symbol, { ts, rsi });
          }
        }
      } catch (err) {
        console.error('Error handling message', err);
      }
    },
  });

  console.log(`Kafka consumer connected to ${KAFKA_BROKER} and subscribed to topics.`);
}

// HTTP endpoints
app.get('/price', (req, res) => {
  const symbol = (req.query.symbol || '').toString().toUpperCase();
  if (!symbol) return res.status(400).json({ error: 'symbol required' });
  const data = priceStore[symbol] || [];
  // return a shallow copy
  res.json(data.slice());
});

app.get('/rsi', (req, res) => {
  const symbol = (req.query.symbol || '').toString().toUpperCase();
  if (!symbol) return res.status(400).json({ error: 'symbol required' });
  const data = rsiStore[symbol] || [];
  res.json(data.slice());
});

app.get('/health', (req, res) => res.json({ ok: true }));

// Start everything
app.listen(PORT, async () => {
  console.log(`Dashboard backend listening on http://localhost:${PORT}`);
  try {
    await startConsumer();
  } catch (err) {
    console.error('Failed to start Kafka consumer', err);
    process.exit(1);
  }
});
